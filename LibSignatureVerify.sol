// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";

/**
 * @title LibSignatureVerify
 * @dev Library for EIP-712 signature verification of reward claim attestations.
 * 
 * This library provides secure signature verification for:
 * - User reward claim attestations (for reward claim)
 * 
 * Uses OpenZeppelin's SignatureChecker for robust signature validation.
 * 
 * @notice All signatures must be generated by the authorized backend signer.
 * @notice Signatures are tied to specific contract addresses and chain IDs for security.
 */
library LibSignatureVerify {

    /// @dev Type hash for reward claim attestation struct following EIP-712 standard.
    bytes32 private constant _REWARD_CLAIM_ATTEST_TYPEHASH = 
        keccak256("RewardClaimAttestation(string playerId,uint256 amount,uint256 eventId)");

    /**
     * @notice Verify a reward claim attestation signature for a user.
     * @dev Validates that the backend has attested to a user's reward claim using EIP-712 signature.
     * 
     * @param playerId The player ID of the user whose reward is being claimed.
     * @param amount The amount of reward being claimed.
     * @param eventId The event ID of the user whose reward is being claimed.
     * @param signature The EIP-712 signature from the backend signer.
     * @param trustedSigner The authorized backend signer address.
     * @param verifyingContract The contract address that will verify this signature.
     * 
     * @return True if the signature is valid and matches the provided parameters.
     * 
     * @dev This function is used during reward claim to verify user eligibility.
     * @dev The signature must be generated by the authorized backend signer.
     * @dev The signature is tied to the specific contract address and chain ID.
     * @dev The signature is wallet-independent and can be used by any wallet.
     * 
     * @custom:security This function includes replay protection.
     * Signatures are tied to specific player IDs to prevent reuse across different contexts.
     */
    function verifyRewardClaim(
        string memory playerId,
        uint256 amount,
        uint256 eventId,
        bytes calldata signature,
        address trustedSigner,
        address verifyingContract
    ) internal view returns (bool) {
        // pack the struct fields
        bytes32 structHash = keccak256(
            abi.encode(
                _REWARD_CLAIM_ATTEST_TYPEHASH,
                keccak256(bytes(playerId)),
                amount,
                eventId
            )
        );

        // calculate the digest using EIPâ€‘712 domain with the actual contract address
        bytes32 domainSeparator = keccak256(
            abi.encode(
                keccak256(
                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                ),
                keccak256(bytes("RcadeRewardDistribution")),
                keccak256(bytes("1")),
                block.chainid,
                verifyingContract
            )
        );

        bytes32 digest = keccak256(
            abi.encodePacked("\x19\x01", domainSeparator, structHash)
        );

        // verify signature using SignatureChecker
        return
            SignatureChecker.isValidSignatureNow(
                trustedSigner,
                digest,
                signature
            );
    }
}
